@(form: Form[_root_.orders.OrderForm], orderList: Seq[_root_.orders.Order], kafkaEvents: Seq[_root_.orders.OrderPlacedEvent])(implicit request: RequestHeader)

@main("Place Order") {
    <h1>Place Order</h1>

    <div class="concept-banner">
        <h3>Advanced Concepts: Kafka Producer/Consumer, Event Serialization, JSON Formats, Async Messaging</h3>
        <p>When an order is placed, an <code>OrderPlacedEvent</code> is published to Kafka. A background consumer thread reads events and displays them below. This demonstrates event-driven architecture with typed JSON serialization using Play's <code>Format</code> type class.</p>

        <details class="code-callout">
            <summary>Event Case Class + JSON Format (given) <span class="callout-source">OrderPlacedEvent.scala</span></summary>
            <pre><code>case class OrderPayload(id: Long, userName: String, itemName: String, quantity: Int)

object OrderPayload:
  given Format[OrderPayload] = Json.format[OrderPayload]

case class OrderPlacedEvent(eventType: String, timestamp: String, order: OrderPayload)

object OrderPlacedEvent:
  given Format[OrderPlacedEvent] = Json.format[OrderPlacedEvent]

  def fromOrder(order: Order): OrderPlacedEvent =
    OrderPlacedEvent(
      eventType = "OrderPlaced",
      timestamp = Instant.now().toString,
      order = OrderPayload(order.id, order.userName, order.itemName, order.quantity)
    )</code></pre>
        </details>

        <details class="code-callout">
            <summary>Kafka Producer &mdash; Publish After DB Write <span class="callout-source">OrderController.scala</span></summary>
            <pre><code>def placeOrder() = Action.async { implicit request =&gt;
  orderForm.bindFromRequest().fold(
    formWithErrors =&gt; ...,
    orderData =&gt;
      orderRepository.create(orderData.userName, orderData.itemName, orderData.quantity).map { order =&gt;
        val event = OrderPlacedEvent.fromOrder(order)
        kafkaProducer.publish(orderPlacedTopic, order.id.toString, Json.toJson(event).toString())
          .recover { case ex =&gt; logger.error(s"Failed to publish Kafka event", ex) }
        Redirect(routes.OrderController.showForm()).flashing("success" -&gt; "Order placed!")
      }
  )
}</code></pre>
        </details>

        <details class="code-callout">
            <summary>Kafka Consumer &mdash; Background Poll Thread <span class="callout-source">OrderEventConsumer.scala</span></summary>
            <pre><code>private val events: ListBuffer[OrderPlacedEvent] = ListBuffer.empty
@@volatile private var running = true

private val pollThread = new Thread(() =&gt;
  consumer.subscribe(Collections.singletonList(topic))
  while running do
    try
      val records = consumer.poll(Duration.ofMillis(500))
      for record &lt;- records.asScala do
        Json.parse(record.value()).validate[OrderPlacedEvent].fold(
          errors =&gt; logger.warn(s"Failed to parse: $errors"),
          event =&gt;
            events.synchronized { events += event }
            logger.info(s"Consumed OrderPlaced event for order ${event.order.id}")
        )
    catch
      case _: WakeupException =&gt; ()
      case ex: Exception =&gt; logger.error("Error polling order events", ex)
, "order-event-consumer")
pollThread.setDaemon(true)
pollThread.start()</code></pre>
        </details>
    </div>

    @request.flash.get("success").map { message =>
        <div class="success">@message</div>
    }

    @helper.form(action = orders.routes.OrderController.placeOrder()) {
        @helper.CSRF.formField

        <div class="form-group">
            <label for="userName">Your Name</label>
            <input type="text" id="userName" name="userName" value="@form("userName").value.getOrElse("")" required>
            @form.error("userName").map { error =>
                <div class="error-msg">@error.message</div>
            }
        </div>

        <div class="form-group">
            <label for="itemName">Item</label>
            <input type="text" id="itemName" name="itemName" value="@form("itemName").value.getOrElse("")" required>
            @form.error("itemName").map { error =>
                <div class="error-msg">@error.message</div>
            }
        </div>

        <div class="form-group">
            <label for="quantity">Quantity</label>
            <input type="number" id="quantity" name="quantity" value="@form("quantity").value.getOrElse("1")" min="1" required>
            @form.error("quantity").map { error =>
                <div class="error-msg">@error.message</div>
            }
        </div>

        <div class="btn-group">
            <button type="submit" class="btn-blue">Place Order</button>
            <button type="button" class="btn-autofill" onclick="autoFillOrder()">Auto Fill</button>
        </div>
    }

    <script>
    function autoFillOrder() {
        var orders = [
            { user: 'Alice Johnson', item: 'MacBook Pro 16"', qty: 1 },
            { user: 'Bob Martinez', item: 'Wireless Mouse', qty: 3 },
            { user: 'Carol Chen', item: 'Standing Desk', qty: 1 },
            { user: 'David Kim', item: 'Mechanical Keyboard', qty: 2 },
            { user: 'Eva Rossi', item: 'Noise-Cancelling Headphones', qty: 1 },
            { user: 'Frank Okafor', item: 'USB-C Hub', qty: 4 },
            { user: 'Grace Liu', item: '27" 4K Monitor', qty: 2 },
            { user: 'Henry Park', item: 'Ergonomic Chair', qty: 1 }
        ];
        var o = orders[Math.floor(Math.random() * orders.length)];
        document.getElementById('userName').value = o.user;
        document.getElementById('itemName').value = o.item;
        document.getElementById('quantity').value = o.qty;
    }
    </script>

    <h2>Orders</h2>
    @if(orderList.isEmpty) {
        <p>No orders placed yet.</p>
    } else {
        <table>
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Name</th>
                    <th>Item</th>
                    <th>Qty</th>
                </tr>
            </thead>
            <tbody>
                @for(order <- orderList) {
                    <tr>
                        <td>@order.id</td>
                        <td>@order.userName</td>
                        <td>@order.itemName</td>
                        <td>@order.quantity</td>
                    </tr>
                }
            </tbody>
        </table>
    }

    <h2>Checkout Emails (Kafka Events)</h2>
    @if(kafkaEvents.isEmpty) {
        <p>No checkout emails queued yet.</p>
    } else {
        <table>
            <thead>
                <tr>
                    <th>Event Type</th>
                    <th>Timestamp</th>
                    <th>Order ID</th>
                    <th>Name</th>
                    <th>Item</th>
                    <th>Qty</th>
                </tr>
            </thead>
            <tbody>
                @for(event <- kafkaEvents) {
                    <tr>
                        <td>@event.eventType</td>
                        <td>@event.timestamp</td>
                        <td>@event.order.id</td>
                        <td>@event.order.userName</td>
                        <td>@event.order.itemName</td>
                        <td>@event.order.quantity</td>
                    </tr>
                }
            </tbody>
        </table>
    }
}
